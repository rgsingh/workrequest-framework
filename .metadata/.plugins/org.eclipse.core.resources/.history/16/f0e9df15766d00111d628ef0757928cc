package com.rgsinfotech.workqueue;

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * Hello world!
 *
 */
public class App 
{
	private static String THREAD_PREFIX = "workqueue";
	
    public static void main( String[] args )
    {
    	
    	
    	ExecutorService executor = Executors.newSingleThreadExecutor(new LoggingThreadFactory(THREAD_PREFIX));


    	executor.submit(new Worker(queue));    	
    	
    	// Create a bounded blocking queue of integers
    	final int capacity = 10;
    	BlockingQueue<Integer> queue = new ArrayBlockingQueue<Integer>(capacity);

    	// Create a set of worker threads
    	final int numWorkers = 2;
    	Worker[] workers = new Worker[numWorkers];
    	for (int i=0; i<workers.length; i++) {
    	    workers[i] = new Worker(queue);
    	    workers[i].start();
    	}

    	try {
    	    // Add some work to the queue; block if the queue is full.
    	    // Note that null cannot be added to a blocking queue.
    	    for (int i=0; i<100; i++) {
    	        queue.put(i);
    	    }

    	    // Add special end-of-stream markers to terminate the workers
    	    for (int i=0; i<workers.length; i++) {
    	        queue.put(Worker.NO_MORE_WORK);
    	    }
    	} catch (InterruptedException e) {
    	}    	

    }
}
